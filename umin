#!/usr/bin/jruby


require 'unimidi'
require_relative 'midi'

module JDXI
  extend MIDI
  ID = [0x41] # Roland
  MODEL_ID = [0x00, 0x00, 0x00, 0x0E] # JD-XI
  BROADCAST = [0x7F]
  DEVICE_ID = [0x10]
  DATA_REQUEST = [0x11]
  DATA_SET = [0x12]
end

input = UniMIDI::Input.find_by_name('UR22 [hw:1,0,0]')

exit_requested = false
Kernel.trap('INT') { exit }

blacklist = MIDI::CLOCK + MIDI::SENSE

Thread.new do
  input.open do |input|
    loop do
      packages = input.gets
      packages.each do |package|
        timestamp = package[:timestamp]
        data = package[:data]
        status = data[0]
        next if blacklist.include?(status)
        # print("#{timestamp}: ")
        puts("< #{MIDI.b10_array_to_hex_array_s(data)}")
      end
    end
  end
end

output = UniMIDI::Output.find_by_name("UR22 [hw:1,0,0]").open

loop do
  # Note On
  # output.puts(0x91, 0x3E, 0x5F)

  # Identification Request
  # output.puts([0xF0, 0x7E, 0x7F, 0x06, 0x01, 0xF7])

  # Set Parameter
  effect_offset = 0x0003
  data = 0x22 # 100
  # Effect 1 Reverb Send Level of Temporary (current) Program
  address = MIDI.address(0x18000000, 0x0200, effect_offset)
  message =
      MIDI::SYSEX +
      JDXI::ID +
      JDXI::DEVICE_ID +
      JDXI::MODEL_ID +
      JDXI::DATA_SET +
      MIDI.int_to_byte_array_4(address) +
      [data] +
      MIDI.checksum(address, data) +
      MIDI::SYSEX_END
  # size = 0x0000DDDD
  # address = MIDI.address(0x02000000, 0x0000, 0x0)
  # message =
  #     MIDI::SYSEX +
  #     JDXI::ID +
  #     JDXI::BROADCAST +
  #     JDXI::MODEL_ID +
  #     JDXI::DATA_SET +
  #     MIDI.int_to_byte_array_4(address) +
  #     MIDI.int_to_byte_array_4(size) +
  #     MIDI.checksum(address, size) +
  #     MIDI::SYSEX_END
  puts "> #{MIDI.b10_array_to_hex_array_s(message)}"
  output.puts(message)
  sleep(5)
  # output.puts(0x81, 0x3E, 0x5F) # Note Off
end

puts 'finished'
# exit
